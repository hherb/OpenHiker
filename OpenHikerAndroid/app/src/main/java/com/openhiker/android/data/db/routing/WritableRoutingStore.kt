/*
 * OpenHiker - Offline Hiking Navigation
 * Copyright (C) 2024 - 2026 Dr Horst Herb
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.openhiker.android.data.db.routing

import android.content.ContentValues
import android.database.sqlite.SQLiteDatabase
import com.openhiker.core.formats.RoutingDbSchema
import com.openhiker.core.routing.RoutingEdge
import com.openhiker.core.routing.RoutingNode
import java.io.Closeable
import java.io.File

/**
 * Writable SQLite store for building a per-region routing graph database.
 *
 * Creates the routing database schema (nodes, edges, metadata tables)
 * and provides batch-insert methods used by [RoutingGraphBuilder] during
 * the OSM data â†’ routing graph construction pipeline.
 *
 * After graph building completes, the database file is opened read-only
 * by [RoutingStore] for A* routing queries.
 *
 * @property path Absolute filesystem path for the new .routing.db file.
 */
class WritableRoutingStore(private val path: String) : Closeable {

    private var db: SQLiteDatabase? = null

    /** Whether the database is currently open. */
    val isOpen: Boolean get() = db?.isOpen == true

    /**
     * Creates or opens the routing database and initialises the schema.
     *
     * If the file already exists, it is deleted and recreated.
     * Creates all tables and indexes defined in [RoutingDbSchema].
     */
    fun create() {
        // Delete any existing file to start fresh
        val file = File(path)
        if (file.exists()) {
            file.delete()
        }
        file.parentFile?.mkdirs()

        db = SQLiteDatabase.openOrCreateDatabase(path, null)
        createSchema()
    }

    /**
     * Inserts a batch of routing nodes within a transaction.
     *
     * Uses a single database transaction for efficiency. For large graphs
     * (100k+ nodes), call this in chunks of ~10,000 nodes.
     *
     * @param nodes The routing nodes to insert.
     */
    fun insertNodes(nodes: List<RoutingNode>) {
        val database = db ?: throw RoutingStoreError.DatabaseNotOpen()
        database.beginTransaction()
        try {
            val values = ContentValues()
            for (node in nodes) {
                values.clear()
                values.put(RoutingDbSchema.COL_NODE_ID, node.id)
                values.put(RoutingDbSchema.COL_NODE_LATITUDE, node.latitude)
                values.put(RoutingDbSchema.COL_NODE_LONGITUDE, node.longitude)
                if (node.elevation != null) {
                    values.put(RoutingDbSchema.COL_NODE_ELEVATION, node.elevation)
                } else {
                    values.putNull(RoutingDbSchema.COL_NODE_ELEVATION)
                }
                database.insertWithOnConflict(
                    RoutingDbSchema.TABLE_NODES,
                    null,
                    values,
                    SQLiteDatabase.CONFLICT_REPLACE
                )
            }
            database.setTransactionSuccessful()
        } finally {
            database.endTransaction()
        }
    }

    /**
     * Inserts a batch of routing edges within a transaction.
     *
     * The edge ID is auto-generated by the database (autoincrement).
     *
     * @param edges The routing edges to insert.
     */
    fun insertEdges(edges: List<RoutingEdge>) {
        val database = db ?: throw RoutingStoreError.DatabaseNotOpen()
        database.beginTransaction()
        try {
            val values = ContentValues()
            for (edge in edges) {
                values.clear()
                values.put(RoutingDbSchema.COL_EDGE_FROM_NODE, edge.fromNode)
                values.put(RoutingDbSchema.COL_EDGE_TO_NODE, edge.toNode)
                values.put(RoutingDbSchema.COL_EDGE_DISTANCE, edge.distance)
                values.put(RoutingDbSchema.COL_EDGE_ELEVATION_GAIN, edge.elevationGain)
                values.put(RoutingDbSchema.COL_EDGE_ELEVATION_LOSS, edge.elevationLoss)
                values.putOrNull(RoutingDbSchema.COL_EDGE_SURFACE, edge.surface)
                values.putOrNull(RoutingDbSchema.COL_EDGE_HIGHWAY_TYPE, edge.highwayType)
                values.putOrNull(RoutingDbSchema.COL_EDGE_SAC_SCALE, edge.sacScale)
                values.putOrNull(RoutingDbSchema.COL_EDGE_TRAIL_VISIBILITY, edge.trailVisibility)
                values.putOrNull(RoutingDbSchema.COL_EDGE_NAME, edge.name)
                if (edge.osmWayId != null) {
                    values.put(RoutingDbSchema.COL_EDGE_OSM_WAY_ID, edge.osmWayId)
                } else {
                    values.putNull(RoutingDbSchema.COL_EDGE_OSM_WAY_ID)
                }
                values.put(RoutingDbSchema.COL_EDGE_COST, edge.cost)
                values.put(RoutingDbSchema.COL_EDGE_REVERSE_COST, edge.reverseCost)
                values.put(RoutingDbSchema.COL_EDGE_IS_ONEWAY, if (edge.isOneway) 1 else 0)
                database.insert(RoutingDbSchema.TABLE_EDGES, null, values)
            }
            database.setTransactionSuccessful()
        } finally {
            database.endTransaction()
        }
    }

    /**
     * Writes a metadata key-value pair.
     *
     * @param key The metadata key (e.g., "region_id", "build_date").
     * @param value The metadata value.
     */
    fun setMetadata(key: String, value: String) {
        val database = db ?: throw RoutingStoreError.DatabaseNotOpen()
        val values = ContentValues().apply {
            put(RoutingDbSchema.COL_META_KEY, key)
            put(RoutingDbSchema.COL_META_VALUE, value)
        }
        database.insertWithOnConflict(
            RoutingDbSchema.TABLE_METADATA,
            null,
            values,
            SQLiteDatabase.CONFLICT_REPLACE
        )
    }

    /**
     * Closes the database connection.
     */
    override fun close() {
        db?.close()
        db = null
    }

    /**
     * Creates all tables and indexes defined in [RoutingDbSchema].
     */
    private fun createSchema() {
        val database = db ?: return
        database.execSQL(RoutingDbSchema.CREATE_NODES_TABLE)
        database.execSQL(RoutingDbSchema.CREATE_EDGES_TABLE)
        database.execSQL(RoutingDbSchema.CREATE_METADATA_TABLE)
        database.execSQL(RoutingDbSchema.CREATE_EDGES_FROM_INDEX)
        database.execSQL(RoutingDbSchema.CREATE_EDGES_TO_INDEX)
        database.execSQL(RoutingDbSchema.CREATE_NODES_LAT_INDEX)
    }
}

/**
 * Extension to put a nullable string into ContentValues.
 */
private fun ContentValues.putOrNull(key: String, value: String?) {
    if (value != null) {
        put(key, value)
    } else {
        putNull(key)
    }
}
