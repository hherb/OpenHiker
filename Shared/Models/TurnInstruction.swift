// Copyright (C) 2024-2026 Dr Horst Herb
//
// This file is part of OpenHiker.
//
// OpenHiker is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OpenHiker is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with OpenHiker. If not, see <https://www.gnu.org/licenses/>.

import Foundation
import CoreLocation

// MARK: - Turn Direction

/// The type of turn manoeuvre at a junction along a computed route.
///
/// Each case maps to a human-readable instruction string and an SF Symbol
/// for the navigation overlay. The angle ranges are:
/// - `.straight`: -15 to +15 degrees
/// - `.slightLeft` / `.slightRight`: 15 to 45 degrees
/// - `.left` / `.right`: 45 to 135 degrees
/// - `.sharpLeft` / `.sharpRight`: 135 to 170 degrees
/// - `.uTurn`: 170 to 180 degrees
enum TurnDirection: String, Codable, Sendable, CaseIterable {
    /// The very first instruction: "Start heading north".
    case start
    /// Continue straight ahead (bearing change < 15 degrees).
    case straight
    /// Bear slightly left (bearing change 15-45 degrees left).
    case slightLeft
    /// Turn left (bearing change 45-135 degrees left).
    case left
    /// Sharp left turn (bearing change 135-170 degrees left).
    case sharpLeft
    /// Bear slightly right (bearing change 15-45 degrees right).
    case slightRight
    /// Turn right (bearing change 45-135 degrees right).
    case right
    /// Sharp right turn (bearing change 135-170 degrees right).
    case sharpRight
    /// U-turn (bearing change > 170 degrees in either direction).
    case uTurn
    /// Final instruction: "Arrive at destination".
    case arrive

    /// SF Symbol name for the turn direction arrow shown in the navigation overlay.
    var sfSymbolName: String {
        switch self {
        case .start:        return "location.north.fill"
        case .straight:     return "arrow.up"
        case .slightLeft:   return "arrow.up.left"
        case .left:         return "arrow.turn.up.left"
        case .sharpLeft:    return "arrow.turn.down.left"
        case .slightRight:  return "arrow.up.right"
        case .right:        return "arrow.turn.up.right"
        case .sharpRight:   return "arrow.turn.down.right"
        case .uTurn:        return "arrow.uturn.down"
        case .arrive:       return "flag.checkered"
        }
    }

    /// Short human-readable verb for the turn direction (e.g., "Turn left").
    var verb: String {
        switch self {
        case .start:        return "Start"
        case .straight:     return "Continue straight"
        case .slightLeft:   return "Bear left"
        case .left:         return "Turn left"
        case .sharpLeft:    return "Sharp left"
        case .slightRight:  return "Bear right"
        case .right:        return "Turn right"
        case .sharpRight:   return "Sharp right"
        case .uTurn:        return "U-turn"
        case .arrive:       return "Arrive"
        }
    }
}

// MARK: - Turn Instruction

/// A single turn-by-turn navigation instruction at a junction along a route.
///
/// Generated by ``TurnInstructionGenerator/generate(from:)`` from a ``ComputedRoute``.
/// Each instruction specifies where a manoeuvre occurs, what direction to turn,
/// and the distances to help the navigator anticipate the next action.
///
/// ## Example
/// ```swift
/// // "In 1.2 km, turn left onto Blue Ridge Trail"
/// let instruction = TurnInstruction(
///     coordinate: CLLocationCoordinate2D(latitude: 47.42, longitude: 10.99),
///     direction: .left,
///     bearing: 270,
///     distanceFromPrevious: 1200,
///     cumulativeDistance: 3400,
///     trailName: "Blue Ridge Trail",
///     description: "Turn left onto Blue Ridge Trail"
/// )
/// ```
struct TurnInstruction: Codable, Sendable, Identifiable, Equatable {
    /// Stable identity for SwiftUI lists and ForEach.
    var id: String { "\(coordinate.latitude),\(coordinate.longitude),\(cumulativeDistance)" }

    /// Geographic coordinate where this turn occurs.
    let coordinate: CLLocationCoordinate2D

    /// The type of turn manoeuvre at this point.
    let direction: TurnDirection

    /// The outgoing bearing in degrees (0 = north, 90 = east).
    ///
    /// Used to rotate the direction arrow in the navigation overlay.
    let bearing: Double

    /// Distance from the previous turn instruction in metres.
    let distanceFromPrevious: Double

    /// Distance from the route start to this point in metres.
    let cumulativeDistance: Double

    /// OSM trail name at this junction, or `nil` if the trail is unnamed.
    let trailName: String?

    /// Human-readable instruction text (e.g., "Turn left onto Blue Ridge Trail").
    let description: String

    static func == (lhs: TurnInstruction, rhs: TurnInstruction) -> Bool {
        lhs.coordinate.latitude == rhs.coordinate.latitude
            && lhs.coordinate.longitude == rhs.coordinate.longitude
            && lhs.direction == rhs.direction
            && lhs.cumulativeDistance == rhs.cumulativeDistance
    }
}

// MARK: - Bearing & Direction Helpers

/// Pure-function helpers for computing bearings and turn directions from coordinates.
///
/// These are used by ``TurnInstructionGenerator`` to determine the turn angle
/// at each junction. All angles are in degrees.
enum BearingCalculator {

    /// Degrees-to-radians conversion factor.
    private static let degreesToRadians = Double.pi / 180.0

    /// Radians-to-degrees conversion factor.
    private static let radiansToDegrees = 180.0 / Double.pi

    /// Computes the initial bearing (forward azimuth) from one coordinate to another.
    ///
    /// Uses the spherical law of cosines formula. The result is normalized to 0-360 degrees
    /// where 0 = north, 90 = east, 180 = south, 270 = west.
    ///
    /// - Parameters:
    ///   - from: The starting coordinate.
    ///   - to: The destination coordinate.
    /// - Returns: Bearing in degrees (0-360).
    static func bearing(from: CLLocationCoordinate2D, to: CLLocationCoordinate2D) -> Double {
        let lat1 = from.latitude * degreesToRadians
        let lat2 = to.latitude * degreesToRadians
        let dLon = (to.longitude - from.longitude) * degreesToRadians

        let y = sin(dLon) * cos(lat2)
        let x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon)
        let bearing = atan2(y, x) * radiansToDegrees

        return normalizeDegrees(bearing)
    }

    /// Computes the bearing from a sequence of coordinates (the last ~50m of a trail segment).
    ///
    /// Uses the average direction of the last portion of the coordinate sequence for a smoother
    /// bearing estimate. Falls back to the simple two-point bearing if fewer than 2 points exist.
    ///
    /// - Parameters:
    ///   - coordinates: Ordered coordinates approaching or leaving the junction.
    ///   - approaching: If `true`, computes the bearing arriving at the junction (last→second-to-last reversed).
    ///     If `false`, computes the bearing leaving the junction (first→second).
    /// - Returns: Bearing in degrees (0-360).
    static func bearingFromSegment(
        _ coordinates: [CLLocationCoordinate2D],
        approaching: Bool
    ) -> Double {
        guard coordinates.count >= 2 else {
            return 0
        }

        if approaching {
            // Bearing of the incoming edge: direction from second-to-last to last point
            let from = coordinates[coordinates.count - 2]
            let to = coordinates[coordinates.count - 1]
            return bearing(from: from, to: to)
        } else {
            // Bearing of the outgoing edge: direction from first to second point
            let from = coordinates[0]
            let to = coordinates[1]
            return bearing(from: from, to: to)
        }
    }

    /// Determines the ``TurnDirection`` from a bearing change in degrees.
    ///
    /// The delta is normalized to -180..+180 where positive = right, negative = left.
    ///
    /// - Parameter delta: Bearing change in degrees (-180 to +180).
    /// - Returns: The ``TurnDirection`` corresponding to the angle.
    static func turnDirection(fromBearingDelta delta: Double) -> TurnDirection {
        let normalized = normalizeDelta(delta)
        let absDelta = abs(normalized)

        if absDelta < TurnInstructionConfig.straightThresholdDegrees {
            return .straight
        } else if absDelta < TurnInstructionConfig.slightTurnThresholdDegrees {
            return normalized > 0 ? .slightRight : .slightLeft
        } else if absDelta < TurnInstructionConfig.normalTurnThresholdDegrees {
            return normalized > 0 ? .right : .left
        } else if absDelta < TurnInstructionConfig.uTurnThresholdDegrees {
            return normalized > 0 ? .sharpRight : .sharpLeft
        } else {
            return .uTurn
        }
    }

    /// Returns a cardinal direction string for a bearing (e.g., "north", "southeast").
    ///
    /// - Parameter degrees: Bearing in degrees (0-360).
    /// - Returns: A cardinal direction string.
    static func cardinalDirection(_ degrees: Double) -> String {
        let normalized = normalizeDegrees(degrees)
        switch normalized {
        case 337.5...360, 0..<22.5:     return "north"
        case 22.5..<67.5:               return "northeast"
        case 67.5..<112.5:              return "east"
        case 112.5..<157.5:             return "southeast"
        case 157.5..<202.5:             return "south"
        case 202.5..<247.5:             return "southwest"
        case 247.5..<292.5:             return "west"
        case 292.5..<337.5:             return "northwest"
        default:                        return "north"
        }
    }

    /// Normalizes an angle to the range 0-360 degrees.
    ///
    /// - Parameter degrees: The angle to normalize.
    /// - Returns: The equivalent angle in 0-360.
    static func normalizeDegrees(_ degrees: Double) -> Double {
        var result = degrees.truncatingRemainder(dividingBy: 360.0)
        if result < 0 { result += 360.0 }
        return result
    }

    /// Normalizes a bearing delta to the range -180..+180 degrees.
    ///
    /// Positive values indicate a right turn, negative indicate a left turn.
    ///
    /// - Parameter delta: The raw bearing change.
    /// - Returns: Normalized delta in -180..+180.
    static func normalizeDelta(_ delta: Double) -> Double {
        var result = delta.truncatingRemainder(dividingBy: 360.0)
        if result > 180 { result -= 360 }
        if result < -180 { result += 360 }
        return result
    }
}

// MARK: - Turn Instruction Configuration

/// Configuration constants for turn instruction generation.
///
/// All thresholds are in degrees. These control when a junction is classified
/// as "straight", "slight turn", "turn", "sharp turn", or "u-turn".
enum TurnInstructionConfig {

    /// Maximum bearing change (degrees) still classified as "straight".
    static let straightThresholdDegrees: Double = 15.0

    /// Maximum bearing change (degrees) for "slight turn" (left or right).
    static let slightTurnThresholdDegrees: Double = 45.0

    /// Maximum bearing change (degrees) for "turn" (left or right).
    static let normalTurnThresholdDegrees: Double = 135.0

    /// Maximum bearing change (degrees) before classifying as "u-turn".
    static let uTurnThresholdDegrees: Double = 170.0

    /// Minimum distance between consecutive turn instructions (metres).
    ///
    /// Junctions closer than this to the previous instruction are merged
    /// to avoid a flood of rapid-fire instructions on complex trail networks.
    static let minimumInstructionSpacingMetres: Double = 50.0
}

// MARK: - Turn Instruction Generator

/// Generates turn-by-turn navigation instructions from a ``ComputedRoute``.
///
/// At each junction node along the route, computes the bearing change between
/// the incoming and outgoing trail segments and classifies it as a turn direction.
/// Adds a "start" instruction at the beginning and an "arrive" instruction at the end.
///
/// ## Algorithm
/// 1. For each junction node (shared between two consecutive edges):
///    a. Compute the incoming bearing from the last ~50m of the previous edge
///    b. Compute the outgoing bearing from the first ~50m of the next edge
///    c. Calculate `delta = outBearing - inBearing`, normalized to -180..+180
///    d. Map `delta` to a ``TurnDirection``
/// 2. Generate a human-readable description including the trail name if available
/// 3. Filter out instructions too close together (< 50m)
enum TurnInstructionGenerator {

    /// Generates turn instructions from a computed route.
    ///
    /// - Parameter route: The ``ComputedRoute`` output from ``RoutingEngine/findRoute(from:to:via:mode:)``.
    /// - Returns: An ordered array of ``TurnInstruction`` from start to destination.
    static func generate(from route: ComputedRoute) -> [TurnInstruction] {
        guard !route.coordinates.isEmpty else { return [] }
        guard route.edges.count >= 1 else {
            // Single point or no edges — just start + arrive
            return makeStartAndArrive(route: route)
        }

        var instructions: [TurnInstruction] = []
        var cumulativeDistance: Double = 0

        // 1. Start instruction
        let startCoord = route.coordinates[0]
        let firstEdgeBearing = bearingForEdge(route.edges[0], reversed: false, route: route, edgeIndex: 0)
        let startDescription = "Head \(BearingCalculator.cardinalDirection(firstEdgeBearing))"
        instructions.append(TurnInstruction(
            coordinate: startCoord,
            direction: .start,
            bearing: firstEdgeBearing,
            distanceFromPrevious: 0,
            cumulativeDistance: 0,
            trailName: route.edges[0].name,
            description: route.edges[0].name != nil
                ? "\(startDescription) on \(route.edges[0].name!)"
                : startDescription
        ))

        // 2. Junction instructions (at each node between consecutive edges)
        for i in 0..<(route.edges.count - 1) {
            let currentEdge = route.edges[i]
            let nextEdge = route.edges[i + 1]

            cumulativeDistance += currentEdge.distance

            // Compute incoming bearing (end of current edge)
            let inBearing = bearingForEdgeEnd(currentEdge, route: route, edgeIndex: i)

            // Compute outgoing bearing (start of next edge)
            let outBearing = bearingForEdgeStart(nextEdge, route: route, edgeIndex: i + 1)

            // Calculate bearing change
            let delta = outBearing - inBearing
            let direction = BearingCalculator.turnDirection(fromBearingDelta: delta)

            // Skip "straight" if not at a meaningful junction
            if direction == .straight {
                continue
            }

            // Check minimum spacing from previous instruction
            let lastCumulativeDistance = instructions.last?.cumulativeDistance ?? 0
            let spacing = cumulativeDistance - lastCumulativeDistance
            if spacing < TurnInstructionConfig.minimumInstructionSpacingMetres {
                continue
            }

            // Junction coordinate is the shared node between edges
            let junctionCoord = route.nodes[i + 1].coordinate

            // Generate description
            let description = makeDescription(direction: direction, bearing: outBearing, trailName: nextEdge.name)

            instructions.append(TurnInstruction(
                coordinate: junctionCoord,
                direction: direction,
                bearing: outBearing,
                distanceFromPrevious: spacing,
                cumulativeDistance: cumulativeDistance,
                trailName: nextEdge.name,
                description: description
            ))
        }

        // 3. Arrive instruction
        let lastEdge = route.edges[route.edges.count - 1]
        cumulativeDistance += lastEdge.distance
        let lastCumulativeDistance = instructions.last?.cumulativeDistance ?? 0

        let arriveCoord = route.coordinates[route.coordinates.count - 1]
        instructions.append(TurnInstruction(
            coordinate: arriveCoord,
            direction: .arrive,
            bearing: 0,
            distanceFromPrevious: cumulativeDistance - lastCumulativeDistance,
            cumulativeDistance: cumulativeDistance,
            trailName: nil,
            description: "Arrive at destination"
        ))

        return instructions
    }

    // MARK: - Private Helpers

    /// Creates minimal start + arrive instructions for trivially short routes.
    private static func makeStartAndArrive(route: ComputedRoute) -> [TurnInstruction] {
        let startCoord = route.coordinates[0]
        let endCoord = route.coordinates[route.coordinates.count - 1]

        var instructions: [TurnInstruction] = []

        let bearing: Double
        if route.coordinates.count >= 2 {
            bearing = BearingCalculator.bearing(from: startCoord, to: route.coordinates[1])
        } else {
            bearing = 0
        }

        instructions.append(TurnInstruction(
            coordinate: startCoord,
            direction: .start,
            bearing: bearing,
            distanceFromPrevious: 0,
            cumulativeDistance: 0,
            trailName: route.edges.first?.name,
            description: "Head \(BearingCalculator.cardinalDirection(bearing))"
        ))

        instructions.append(TurnInstruction(
            coordinate: endCoord,
            direction: .arrive,
            bearing: 0,
            distanceFromPrevious: route.totalDistance,
            cumulativeDistance: route.totalDistance,
            trailName: nil,
            description: "Arrive at destination"
        ))

        return instructions
    }

    /// Computes the outgoing bearing from the start of an edge.
    ///
    /// Uses the edge's start node and the first intermediate geometry point
    /// (or the end node if no intermediate geometry exists).
    private static func bearingForEdgeStart(
        _ edge: RoutingEdge,
        route: ComputedRoute,
        edgeIndex: Int
    ) -> Double {
        let startNode = route.nodes[edgeIndex]
        let intermediateCoords = EdgeGeometry.unpack(edge.geometry)

        if let firstIntermediate = intermediateCoords.first {
            return BearingCalculator.bearing(from: startNode.coordinate, to: firstIntermediate)
        } else if edgeIndex + 1 < route.nodes.count {
            let endNode = route.nodes[edgeIndex + 1]
            return BearingCalculator.bearing(from: startNode.coordinate, to: endNode.coordinate)
        }
        return 0
    }

    /// Computes the incoming bearing arriving at the end of an edge.
    ///
    /// Uses the last intermediate geometry point (or the start node if none)
    /// and the edge's end node.
    private static func bearingForEdgeEnd(
        _ edge: RoutingEdge,
        route: ComputedRoute,
        edgeIndex: Int
    ) -> Double {
        let endNode = route.nodes[edgeIndex + 1]
        let intermediateCoords = EdgeGeometry.unpack(edge.geometry)

        if let lastIntermediate = intermediateCoords.last {
            return BearingCalculator.bearing(from: lastIntermediate, to: endNode.coordinate)
        } else {
            let startNode = route.nodes[edgeIndex]
            return BearingCalculator.bearing(from: startNode.coordinate, to: endNode.coordinate)
        }
    }

    /// Computes the initial bearing of an edge (from start toward destination).
    private static func bearingForEdge(
        _ edge: RoutingEdge,
        reversed: Bool,
        route: ComputedRoute,
        edgeIndex: Int
    ) -> Double {
        bearingForEdgeStart(edge, route: route, edgeIndex: edgeIndex)
    }

    /// Generates a human-readable description for a turn instruction.
    ///
    /// - Parameters:
    ///   - direction: The turn direction.
    ///   - bearing: The outgoing bearing after the turn.
    ///   - trailName: The name of the trail being entered, or `nil`.
    /// - Returns: A description like "Turn left onto Blue Ridge Trail".
    private static func makeDescription(
        direction: TurnDirection,
        bearing: Double,
        trailName: String?
    ) -> String {
        let verb = direction.verb

        if let name = trailName {
            return "\(verb) onto \(name)"
        } else {
            return "\(verb) heading \(BearingCalculator.cardinalDirection(bearing))"
        }
    }
}
